

import { Note, StrudelConfig, Track } from '../types';
import { getAutoSound, DRUM_MAP } from '../constants';

// Helper for rounding
const round = (num: number, precision: number) => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
};

// Scale constants
const PITCH_MAP: Record<string, number> = {
  'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5, 
  'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
};

const SCALES = {
  major: [0, 2, 4, 5, 7, 9, 11],
  minor: [0, 2, 3, 5, 7, 8, 10]
};

export class StrudelNotation {
  private config: StrudelConfig;

  constructor(config: StrudelConfig) {
    this.config = config;
  }

  public generate(tracks: Track[]): string {
    // 1. Calculate Global Song Duration
    let maxDuration = tracks.reduce((max, t) => {
        const trackMax = t.notes.reduce((m, n) => Math.max(m, n.noteOff), 0);
        return Math.max(max, trackMax);
    }, 0);

    const barDur = (60 / this.config.sourceBpm) * this.config.timeSignature.numerator;
    if (maxDuration === 0) maxDuration = barDur;

    // 2. Generate CPS setup
    let cpsFormula = "";
    if (this.config.cycleUnit === 'bar') {
        const numerator = this.config.timeSignature.numerator || 4;
        cpsFormula = `${this.config.bpm} / 60 / ${numerator}`;
    } else {
        cpsFormula = `${this.config.bpm} / 60`;
    }

    let output = `// Generated by Strudel MIDI Converter\n
    // Source BPM: ${this.config.sourceBpm} | 
    const BPM = ${this.config.bpm};
    setcps(${cpsFormula});\n\n`;

    tracks.forEach(track => {
      if (track.hidden) return;
      if (!track.notes.length) return;

      output += this.processTrack(track, maxDuration);
      output += '\n';
    });

    return output;
  }

  private processTrack(track: Track, globalMaxDuration: number): string {
    // 0. Drum Processing path
    if (track.isDrum) {
        return this.processDrumTrack(track, globalMaxDuration);
    }

    // 1. Standard Melodic Processing
    const notes = this.prepareNotes(track.notes);
    
    // Determine sound logic
    let sound = this.config.globalSound;
    
    if (track.sound) {
      sound = track.sound;
    } else if (this.config.useAutoMapping) {
      const auto = getAutoSound(track);
      if (auto) sound = auto;
    }
    
    // Determine Scale Suffix for Relative Mode
    let scaleSuffix = "";
    if (this.config.notationType === 'relative' && (this.config.key || this.config.playbackKey)) {
        // Use playbackKey if available for output (transposition), otherwise source key
        const k = this.config.playbackKey || this.config.key!;
        scaleSuffix = `\n  .scale("${k.root}${k.averageOctave}:${k.type}")`;
    }

    if (this.config.outputStyle === 'melody+harmony') {
      const { melody, harmony } = this.splitMelodyHarmony(notes);
      let trackOutput = "";

      if (melody.length > 0) {
        const melodyCode = this.renderSequence(melody, globalMaxDuration, false);
        trackOutput += `$${this.formatTrackName(track.name)}_MELODY: \`<\n${melodyCode}\n>\`\n  .as("${this.getAsString(false)}")` + scaleSuffix + `\n  .sound("${sound}");\n\n`;
      }

      if (harmony.length > 0) {
        const harmonyCode = this.renderSequence(harmony, globalMaxDuration, false);
        trackOutput += `$${this.formatTrackName(track.name)}_HARMONY: \`<\n${harmonyCode}\n>\`\n  .as("${this.getAsString(false)}")` + scaleSuffix + `\n  .sound("${sound}");\n\n`;
      }
      return trackOutput;
    }
    
    return `// Unknown output style`;
  }

  private processDrumTrack(track: Track, globalMaxDuration: number): string {
      // Filter out notes that don't map to our drum kit to avoid silence/errors
      const rawNotes = track.notes.filter(n => DRUM_MAP[n.midi]);
      const notes = this.prepareNotes(rawNotes);
      
      const sequence = this.renderSequence(notes, globalMaxDuration, true);
      const bank = track.drumBank || "RolandTR909";
      
      // Note: .bank() is commented out by default as requested
      return `$${this.formatTrackName(track.name)}: \`<\n${sequence}\n>\`\n  .as("s");\n  // .bank("${bank}")\n\n`;
  }

  private formatTrackName(name: string): string {
    return name.toUpperCase()
      .replace(/[^A-Z0-9]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_/, '')
      .replace(/_$/, '');
  }

  private getAsString(isDrum: boolean): string {
    if (isDrum) return "s";
    let s = this.config.notationType === 'absolute' ? "note" : "n";
    if (this.config.includeVelocity) s += ":velocity";
    return s;
  }

  private prepareNotes(rawNotes: Note[]): Note[] {
    let notes = [...rawNotes].sort((a, b) => a.noteOn - b.noteOn);

    if (this.config.isQuantized) {
      const beatDuration = 60 / this.config.sourceBpm; 
      const gridUnit = beatDuration / 4; 
      const strength = this.config.quantizationStrength / 100;

      notes = notes.map(n => {
        const nearestOn = Math.round(n.noteOn / gridUnit) * gridUnit;
        const diffOn = nearestOn - n.noteOn;
        let newOn = n.noteOn;
        
        if (Math.abs(diffOn) * 1000 <= this.config.quantizationThreshold) {
           newOn = n.noteOn + (diffOn * strength);
        }

        const dur = n.noteOff - n.noteOn;
        const nearestDur = Math.round(dur / gridUnit) * gridUnit;
        const diffDur = nearestDur - dur;
        let newDur = dur;
        
        if (Math.abs(diffDur) * 1000 <= this.config.quantizationThreshold) {
           newDur = dur + (diffDur * strength);
        }
        
        if (newDur < gridUnit * 0.1) newDur = gridUnit;

        return { ...n, noteOn: newOn, noteOff: newOn + newDur };
      });
    }
    
    return notes;
  }

  private splitMelodyHarmony(notes: Note[]): { melody: Note[], harmony: Note[] } {
    const melody: Note[] = [];
    const harmony: Note[] = [];
    let lastEnd = 0;

    const sorted = [...notes].sort((a, b) => a.noteOn - b.noteOn);

    sorted.forEach(note => {
      if (note.noteOn >= lastEnd - 0.01) {
        melody.push(note);
        lastEnd = note.noteOff;
      } else {
        harmony.push(note);
      }
    });

    return { melody, harmony };
  }

  private getCycleDuration(): number {
    const beatDur = 60 / this.config.sourceBpm; 
    if (this.config.cycleUnit === 'beat') return beatDur;
    return beatDur * (this.config.timeSignature.numerator || 4);
  }

  private renderSequence(notes: Note[], totalDuration: number, isDrum: boolean): string {
    const cycleDur = this.getCycleDuration();
    const measureDur = (60 / this.config.sourceBpm) * (this.config.timeSignature.numerator || 4);
    
    const tokens: string[] = [];
    let cursor = 0;
    const EPSILON = 0.01;

    // --- SMART WINDOWING STRATEGY ---
    while (cursor < totalDuration - EPSILON) {
        // 1. Check for gap (rest) before next note
        const nextNotes = notes.filter(n => n.noteOn >= cursor - EPSILON).sort((a,b) => a.noteOn - b.noteOn);
        
        if (nextNotes.length === 0) {
            const restDur = totalDuration - cursor;
            tokens.push(this.createRestToken(restDur, cycleDur));
            break;
        }

        const nextNote = nextNotes[0];
        
        // If there is a significant gap before the next note starts, fill with rest
        if (nextNote.noteOn > cursor + EPSILON) {
            const gap = nextNote.noteOn - cursor;
            tokens.push(this.createRestToken(gap, cycleDur));
            cursor = nextNote.noteOn;
        }

        // 2. Define Window Size (Accumulation)
        let blockEnd = cursor + measureDur;
        
        // Find notes that START in this standard window
        let blockNotes = notes.filter(n => n.noteOn >= cursor - EPSILON && n.noteOn < blockEnd - EPSILON);

        // Check if any note in this block extends BEYOND blockEnd
        if (blockNotes.length > 0) {
            const maxEnd = Math.max(...blockNotes.map(n => n.noteOff));
            if (maxEnd > blockEnd + EPSILON) {
                // Snap to nearest measure containing maxEnd
                blockEnd = Math.ceil((maxEnd + EPSILON) / measureDur) * measureDur;
                
                // Re-fetch notes for expanded window
                blockNotes = notes.filter(n => n.noteOn >= cursor - EPSILON && n.noteOn < blockEnd - EPSILON);
            }
        }

        const blockDur = blockEnd - cursor;

        // 3. Render Block
        let blockString = "";
        if (this.config.timingStyle === 'relativeDivision') {
             blockString = this.renderMeasureSubdivision(blockNotes, cursor, blockDur, cycleDur, isDrum);
        } else {
             blockString = this.renderMeasureAbsolute(blockNotes, cursor, blockDur, cycleDur, isDrum);
        }

        if (blockString) tokens.push(blockString);
        cursor = blockEnd;
    }

    // --- POST PROCESSING: MERGE RESTS ---
    const mergedTokens: string[] = [];
    
    for (const token of tokens) {
      if (!token.trim()) continue;
      
      if (this.isRest(token)) {
        const lastIdx = mergedTokens.length - 1;
        if (lastIdx >= 0 && this.isRest(mergedTokens[lastIdx])) {
          const prevDur = this.getRestDuration(mergedTokens[lastIdx]);
          const currDur = this.getRestDuration(token);
          const totalCycles = prevDur + currDur; 
          mergedTokens[lastIdx] = this.createRestTokenCycles(totalCycles);
        } else {
          mergedTokens.push(token);
        }
      } else {
        mergedTokens.push(token);
      }
    }

    // --- FORMATTING INTO LINES ---
    let outputLines: string[] = [];
    let currentLine = "";
    let itemsInLine = 0;
    const itemsPerLine = this.config.measuresPerLine; 

    for (const token of mergedTokens) {
      currentLine += token + " ";
      itemsInLine++;
      if (itemsInLine >= itemsPerLine) {
        outputLines.push(currentLine.trim());
        currentLine = "";
        itemsInLine = 0;
      }
    }
    if (currentLine.trim()) outputLines.push(currentLine.trim());

    return outputLines.join('\n');
  }

  // --- Helpers ---

  private isRest(token: string): boolean {
    const t = token.trim();
    if (/[A-G]/.test(t) || /{/.test(t) || /[0-9]/.test(t.split('@')[0]) || /[a-z][a-z]/.test(t.split(':')[0])) {
         // Added logic to check for drum tokens (which are a-z chars like 'bd', 'sd')
         // If it matches drum tokens, it's not a rest.
         if(t.startsWith('[~]') || t === '~' || t.startsWith('~@')) return true;
         // Special case: check against drum map values if needed, but the generic check usually suffices if drum names don't start with ~
         return false;
    }
    return /^~(@[\d\.]+)?$/.test(t) || /^\[~\](@[\d\.]+)?$/.test(t);
  }

  private getRestDuration(token: string): number {
     const parts = token.split('@');
     if (parts.length === 2) return parseFloat(parts[1]);
     return 1;
  }

  // Expects duration in seconds
  private createRestToken(durationSeconds: number, cycleDur: number): string {
       const cycles = durationSeconds / cycleDur;
       return this.createRestTokenCycles(cycles);
  }

  // Expects duration in cycles
  private createRestTokenCycles(cycles: number): string {
       const r = round(cycles, this.config.durationPrecision);
       const suffix = r === 1 ? "" : `@${r}`;
       
       if (this.config.timingStyle === 'relativeDivision') {
         return `[~]${suffix}`;
       }
       return `~${suffix}`;
  }

  private getRelativeDegree(note: Note): string | number {
    // ALWAYS use the source detected key for analysis to ensure degrees are calculated relative to original pitch
    if (!this.config.key) return (note.midi - 60);

    const { root, averageOctave, type } = this.config.key;
    const rootIndex = PITCH_MAP[root];
    
    // Fallback if root not found
    if (rootIndex === undefined) return (note.midi - 60);

    // Calculate Root MIDI for the detected octave
    // We assume the string passed to .scale() is `${root}${averageOctave}`
    // In Scientific Pitch, Root Octave N starts at MIDI = (N+1)*12 + PitchClass
    const rootMidi = rootIndex + (averageOctave + 1) * 12;
    
    const diff = note.midi - rootMidi;
    const octaveShift = Math.floor(diff / 12);
    // Normalized semitone (0-11)
    const semitone = (diff % 12 + 12) % 12; 

    const intervals = SCALES[type];
    
    // Generate candidates for closest scale degree
    // We check current octave and wrapping neighbors to find true closest
    const candidates = [
        // Previous Octave tail
        ...intervals.map((val, i) => ({ val: val - 12, deg: i - 7 })),
        // Current Octave
        ...intervals.map((val, i) => ({ val: val, deg: i })),
        // Next Octave head
        ...intervals.map((val, i) => ({ val: val + 12, deg: i + 7 }))
    ];

    // Find closest candidate
    let best = candidates[0];
    let minDelta = Math.abs(semitone - best.val);
    let ties = [best];

    for (let i = 1; i < candidates.length; i++) {
        const d = Math.abs(semitone - candidates[i].val);
        if (d < minDelta) {
            minDelta = d;
            best = candidates[i];
            ties = [best];
        } else if (d === minDelta) {
            ties.push(candidates[i]);
        }
    }

    // Tie-breaker
    let selected = ties[0];
    if (ties.length > 1) {
        // Preference for flats or sharps based on Key Root
        // Heuristic: Roots with 'b' or F prefer flats. Others sharp.
        const preferFlat = root.includes('b') || root === 'F' || (type === 'minor' && ['C','F','G','D'].includes(root));
        
        if (preferFlat) {
            // Prefer candidate > semitone (resulting in 'b')
            const c = ties.find(x => x.val > semitone);
            if (c) selected = c;
        } else {
             // Prefer candidate < semitone (resulting in '#')
             const c = ties.find(x => x.val < semitone);
             if (c) selected = c;
        }
    }

    const delta = semitone - selected.val;
    const degree = selected.deg + (octaveShift * 7);

    // Remove quotes from accidentals to match Strudel syntax (0 1 2b)
    if (delta === 0) return degree;

    const sign = delta > 0 ? "#" : "b";
    // Return formatted string with accidentals (e.g. 2b, 0#)
    return `${degree}${sign.repeat(Math.abs(delta))}`;
  }

  private formatNoteVal(note: Note, cycleDur: number, isDrum: boolean, durOverride?: number): string {
    let val: string | number = "";
    
    if (isDrum) {
        val = DRUM_MAP[note.midi] || "?"; 
    } else if (this.config.notationType === 'relative' && (this.config.key || this.config.playbackKey)) {
        val = this.getRelativeDegree(note);
    } else {
        val = this.config.notationType === 'absolute' ? note.note : (note.midi - 60).toString(); 
    }
    
    let suffix = "";
    if (this.config.includeVelocity) {
      suffix += `:${round(note.velocity, 2)}`;
    }

    if (this.config.timingStyle === 'absoluteDuration') {
      const d = durOverride !== undefined ? durOverride : (note.noteOff - note.noteOn);
      const cycles = d / cycleDur;
      if (Math.abs(cycles - 1) < 0.001) return `${val}${suffix}`;
      return `${val}${suffix}@${round(cycles, this.config.durationPrecision)}`;
    } else {
       return `${val}${suffix}`;
    }
  }

  // Strategy 1: Absolute Duration ( @0.5 )
  private renderMeasureAbsolute(notes: Note[], measureStart: number, measureDur: number, cycleDur: number, isDrum: boolean): string {
    const EPSILON = 0.01;
    
    if (notes.length === 0) return this.createRestToken(measureDur, cycleDur);

    let cursor = measureStart;
    let output = "";

    const sorted = [...notes].sort((a,b) => a.noteOn - b.noteOn);

    for (let i = 0; i < sorted.length; i++) {
      const note = sorted[i];
      if (note.noteOn > cursor + EPSILON) {
        const gap = note.noteOn - cursor;
        if (gap > EPSILON) {
             output += `${this.createRestToken(gap, cycleDur)} `;
        }
        cursor += gap;
      } else {
        cursor = Math.max(cursor, note.noteOn);
      }

      const chordNotes = [note];
      let j = i + 1;
      while(j < sorted.length && Math.abs(sorted[j].noteOn - note.noteOn) < EPSILON) {
        chordNotes.push(sorted[j]);
        j++;
      }
      i = j - 1;

      if (chordNotes.length > 1) {
         const maxEnd = Math.max(...chordNotes.map(n => n.noteOff));
         const dur = maxEnd - note.noteOn;
         const noteStrs = chordNotes.map(n => this.formatNoteVal(n, cycleDur, isDrum, 0));
         const cycles = dur / cycleDur;
         const suffix = Math.abs(cycles - 1) < 0.001 ? "" : `@${round(cycles, this.config.durationPrecision)}`;
         output += `{${noteStrs.join(', ')}}${suffix} `;
         cursor = maxEnd;
      } else {
         output += `${this.formatNoteVal(note, cycleDur, isDrum)} `;
         cursor = note.noteOff;
      }
    }
    
    if (cursor < measureStart + measureDur - EPSILON) {
        const rem = (measureStart + measureDur) - cursor;
        output += this.createRestToken(rem, cycleDur);
    }

    return output.trim();
  }

  // Strategy 2: Nested Subdivision [[ a ~ ~ ] [b c]]
  private renderMeasureSubdivision(notes: Note[], measureStart: number, measureDur: number, cycleDur: number, isDrum: boolean): string {
    const cycles = measureDur / cycleDur;
    const cyclesRounded = round(cycles, 4);

    if (notes.length === 0) {
      const suffix = cyclesRounded === 1 ? "" : `@${cyclesRounded}`;
      return `[~]${suffix}`;
    }

    // Determine the rhythm structure based on beats
    const numerator = this.config.timeSignature.numerator || 4;
    const beatDur = measureDur / numerator;

    const beatTokens: string[] = [];

    for (let i = 0; i < numerator; i++) {
      const beatStart = measureStart + (i * beatDur);
      const beatEnd = beatStart + beatDur;
      
      // Filter notes that START within this beat
      const beatNotes = notes.filter(n => n.noteOn >= beatStart - 0.001 && n.noteOn < beatEnd - 0.001);
      
      // Notes sustaining from previous beats into this one
      const sustainedNotes = notes.filter(n => n.noteOn < beatStart - 0.001 && n.noteOff > beatStart + 0.001);

      beatTokens.push(this.renderBeat(beatNotes, sustainedNotes, beatStart, beatDur, isDrum));
    }

    const content = beatTokens.join(" ");
    
    // Check if empty
    if (beatTokens.every(t => t === "~" || t === "[~]")) {
        const suffix = cyclesRounded === 1 ? "" : `@${cyclesRounded}`;
        return `[~]${suffix}`;
    }

    const suffix = cyclesRounded === 1 ? "" : `@${cyclesRounded}`;
    
    return `[${content}]${suffix}`;
  }

  private renderBeat(startedNotes: Note[], sustainedNotes: Note[], startTime: number, duration: number, isDrum: boolean): string {
    if (startedNotes.length === 0 && sustainedNotes.length === 0) return "~";

    // 1. Find optimal resolution
    const possibleResolutions = [1, 2, 3, 4, 6, 8, 12, 16, 24, 32];
    let bestRes = 16; 
    
    // Tolerance for grid alignment
    const ERROR_TOLERANCE = 0.05;

    for (const res of possibleResolutions) {
        const tickDur = duration / res;
        let fits = true;

        // Check Onsets (started notes only)
        for (const n of startedNotes) {
            const rel = n.noteOn - startTime;
            const tick = rel / tickDur;
            if (Math.abs(tick - Math.round(tick)) > ERROR_TOLERANCE) {
                fits = false; break;
            }
        }
        if (!fits) continue;

        // Check Offsets (started + sustained notes)
        for (const n of [...startedNotes, ...sustainedNotes]) {
            if (n.noteOff < startTime + duration - 0.001) {
                 const rel = n.noteOff - startTime;
                 const tick = rel / tickDur;
                 if (Math.abs(tick - Math.round(tick)) > ERROR_TOLERANCE) {
                    fits = false; break;
                 }
            }
        }
        
        if (fits) {
            bestRes = res;
            break; 
        }
    }

    const grid: string[] = new Array(bestRes).fill("~");
    const tickDur = duration / bestRes;

    const addToGrid = (index: number, token: string) => {
        if (index >= bestRes) return;
        const current = grid[index];
        if (current === "~" || current === "") {
            grid[index] = token;
        } else {
            // Polyphony merge
            const existing = current.startsWith("{") ? current.slice(1, -1) : current;
            if (!existing.includes(token)) { // Avoid duplicates if possible
               grid[index] = `{${existing}, ${token}}`;
            }
        }
    };

    // 1. Fill Sustained Notes (coming from previous beats)
    sustainedNotes.forEach(n => {
         const relEnd = n.noteOff - startTime;
         const endTick = Math.min(bestRes, Math.round(relEnd / tickDur));
         for (let i = 0; i < endTick; i++) {
             addToGrid(i, "_");
         }
    });

    // 2. Fill Started Notes
    startedNotes.forEach(note => {
        const relStart = note.noteOn - startTime;
        const startTick = Math.round(relStart / tickDur);
        
        const relEnd = note.noteOff - startTime;
        const endTick = Math.min(bestRes, Math.round(relEnd / tickDur));
        
        if (startTick < bestRes) {
             const val = this.formatNoteVal(note, this.getCycleDuration(), isDrum, 0).replace(/@.*/, '');
             addToGrid(startTick, val);

             // Sustain
             for (let i = startTick + 1; i < endTick; i++) {
                 addToGrid(i, "_");
             }
        }
    });

    // Simplify grid if possible
    if (grid.length === 1) return grid[0];
    
    const isFullHold = grid[0] !== "~" && !grid[0].startsWith("{") && grid.slice(1).every(c => c === "_");
    if (isFullHold) {
        return grid[0];
    }

    return `[${grid.join(" ")}]`;
  }
}